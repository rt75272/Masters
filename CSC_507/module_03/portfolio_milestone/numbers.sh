# #!/bin/bash
# # ---------------------------------------------------------------------------------------
# # BASH Number Generator.
# #
# # Generates a million random integers and saves them to a file named file1.txt. Also, 
# # calculates and displays the runtime.
# #
# # Usage:
# #	$ chmod +x numbers.sh
# #	$ ./numbers.sh
# # ---------------------------------------------------------------------------------------
# n=1000000 # Upper limit.
# num_cores=$(nproc --all) # Get the number of CPU cores available.
# filename=file1.txt # BASH output file.

# # Generate random numbers using /dev/urandom and store them in temp file
# looper() {
#     temp_file="temp_$1.txt" # Temp file for storage.
#     count=$2 # The number of random numbers to generate.
#     # Generate exactly $count random numbers using /dev/urandom.
#     # We will use /dev/urandom to generate random numbers directly.
#     for ((i=0; i<count; i++)); do
#         # Generate a random number between 0 and 65535 (16-bit)
#         echo $(( $(od -An -N2 -tu2 /dev/urandom) )) >> "$temp_file"
#     done
# }

# # Split looper's processing up into the number of available CPU cores.
# multithread() {
#     remaining=$n # Keep track of the remaining numbers to generate.
    
#     # Define the looper function in the same shell context
#     export -f looper
#     export remaining num_cores
    
#     # Distribute the work as evenly as possible among available CPU cores
#     seq 1 $num_cores | xargs -I {} -P $num_cores bash -c "
#         count=\$((remaining / num_cores)); 
#         if [ {} -le \$((remaining % num_cores)) ]; then
#             count=\$((count + 1)); 
#         fi
#         looper {} \$count
#         remaining=\$((remaining - count))" 

#     wait # Wait for all threads to complete execution.
#     cat temp_*.txt > "$filename" # Merge temp files' content into a single output file.
#     rm temp_*.txt # Clean up temporary files.
# }

# # Main driver function.
# main() {
#     start_time=$(date +"%s.%N") # Start runtime timer.
#     multithread # Run several threads to produce the million random integers faster.
#     end_time=$(date +"%s.%N") # End runtime timer.
#     duration=$(echo "$end_time - $start_time" | bc) # Subtract times and store the result.
#     echo "Bash runtime: $(printf "%8.4f" "$duration") seconds" # Display runtime.
#     # Verify the number of lines (should be 1 million)
#     line_count=$(wc -l < "$filename")
#     echo "Total lines generated: $line_count"
# }

# # Big red activation button.
# main





# #!/bin/bash
# # ---------------------------------------------------------------------------------------
# # BASH Number Generator.
# #
# # Generates a million random integers and saves them to a file named file1.txt. Also, 
# # calculates and displays the runtime.
# #
# # Usage:
# #	$ chmod +x numbers.sh
# #	$ ./numbers.sh
# # ---------------------------------------------------------------------------------------
# n=1000000 # Upper limit.
# num_cores=$(nproc --all) # Get the number of cpu cores available.
# filename=file1.txt # BASH output file.

# # Generate numbers based on the passed count
# looper() {
#     temp_file="temp_$1.txt" # Temp file for storage.
#     # jot -r "$2" > "$temp_file" # Generate random numbers and store in temp_file.
#     shuf -i 1-1000000 > "$temp_file"
#     for i in $(seq 1 "$2"); do
#         echo $((RANDOM)) >> "$temp_file" # Append random number to temp file.
#     done
# }

# # Split looper's processing up into the number of available cpu cores.
# multithread() {
#     remaining=$n # Keep track of the remaining numbers to generate.
#     for i in $(seq 1 $num_cores); do
#         if [ $remaining -gt 0 ]; then
#             count=$((remaining / (num_cores - i + 1))) # Evenly distribute remaining numbers
#             if [ $count -eq 0 ]; then
#                 count=1 # Ensure at least one number is generated by the last core
#             fi
#             looper $i $count & # Pass the count to looper.
#             remaining=$((remaining - count)) # Decrease remaining count.
#         fi
#     done
#     wait # Wait for all threads to complete execution.
#     cat temp_*.txt > "$filename" # Move temp files content into a single output file.
# }

# # Main driver function.
# main() {
#     start_time=$(date +"%s.%N") # Start runtime timer.
#     multithread # Run several threads to produce the million random integers faster.
#     end_time=$(date +"%s.%N") # End runtime timer.
#     duration=$(echo "$end_time - $start_time" | bc) # Subtract times and store the result.
#     echo "Bash runtime: $(printf "%8.4f" "$duration") seconds" # Display runtime.
# }

# # Big red activation button.
# main



#!/bin/bash
# ---------------------------------------------------------------------------------------
# BASH Number Generator.
#
# Generates a million random integers and saves them to a file named file1.txt. Also, 
# calculates and displays the runtime.
#
# Usage:
#	$ chmod +x numbers.sh
#	$ ./numbers.sh
# ---------------------------------------------------------------------------------------
n=1000000 # Upper limit.
num_cores=$(nproc --all) # Get the number of CPU cores available.
filename=file1.txt # BASH output file.

# Generate numbers based on the passed count
looper() {
    temp_file="temp_$1.txt" # Temp file for storage.
    
    # Generate $2 random numbers in the range from 1 to 1000000 using shuf
    shuf -i 1-1000000 -n "$2" > "$temp_file" # shuf generates random numbers and stores them in temp_file.
}

# Split looper's processing up into the number of available CPU cores.
multithread() {
    remaining=$n # Keep track of the remaining numbers to generate.
    for i in $(seq 1 $num_cores); do
        if [ $remaining -gt 0 ]; then
            # Evenly distribute remaining numbers among cores
            count=$((remaining / (num_cores - i + 1))) 
            if [ $count -eq 0 ]; then
                count=1 # Ensure at least one number is generated by the last core
            fi
            looper $i $count & # Pass the count to looper.
            remaining=$((remaining - count)) # Decrease remaining count.
        fi
    done
    wait # Wait for all threads to complete execution.
    cat temp_*.txt > "$filename" # Concatenate temp files content into a single output file.
    rm temp_*.txt # Clean up temporary files.
}

# Main driver function.
main() {
    start_time=$(date +"%s.%N") # Start runtime timer.
    multithread # Run several threads to produce the million random integers faster.
    end_time=$(date +"%s.%N") # End runtime timer.
    duration=$(echo "$end_time - $start_time" | bc) # Subtract times and store the result.
    echo "Bash runtime: $(printf "%8.4f" "$duration") seconds" # Display runtime.
}

# Big red activation button.
main

